<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>再生核方法-第零章 算子理论基础 | Wei Liu</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="stylesheet" href="/css/bundle.css">
	<link rel="icon" href="/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="/icons/32.png" sizes="32x32" type="image/png">
		
</head>
<body class="body kind-page">
	<header class="header">
	<a class="logo" href="/">Wei Liu</a>
	
<nav class="main-nav" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="/">
					
					<span class="main-nav__text">主页</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/cn/">
					
					<span class="main-nav__text">日志</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/research/">
					
					<span class="main-nav__text">研究</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/poem/">
					
					<span class="main-nav__text">诗词</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/cn_note/">
					
					<span class="main-nav__text">笔记</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/en/">
					
					<span class="main-nav__text">EBlog</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/en_note/">
					
					<span class="main-nav__text">Note</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
		
		<div class="single block">
			<article class="entry">
				<h1 class="entry__title">再生核方法-第零章 算子理论基础</h1>
				<div class="entry__content">
<link href="/rmarkdown-libs/anchor-sections/anchor-sections.css" rel="stylesheet" />
<script src="/rmarkdown-libs/anchor-sections/anchor-sections.js"></script>


<p><strong>再生核方法-第零章 算子理论基础</strong></p>
<p><strong>闲居</strong></p>
<p><em>2020年11月于西财明辨园</em></p>
<div id="空间" class="section level1">
<h1>空间</h1>
<div id="线性向量空间" class="section level2">
<h2>线性（向量）空间</h2>
<p>最基本的空间是线性空间，或者称为向量空间，它满足八条公理，在该空间上定义了两种运算，向量加法和数乘运算。</p>
</div>
<div id="内积空间" class="section level2">
<h2>内积空间</h2>
<p>然后根据线性空间，我们可以找出它的一些具有更好性质的子空间，包括度量空间、赋范空间和内积空间。
引入度量空间的动机，简要概括就是希望对几何空间中的两个向量的距离进行度量。引入赋范空间是对几何空间中的向量的长度进行度量，从而两个向量之间可以根据长度来进行大小比较。而最厉害的内积空间就是对空间中的两个向量之间的角度进行度量，并且内积可以诱导出范数，范数可以诱导出度量，所以内积空间可以对空间中的元素其他方面进行更充分的度量和描述。
我们知道在线性空间中，线性结构使得我们可以进行加法和标量乘法的运算，然而向量的其他特性也是很重要的，比如单个向量的长度，两个向量之间的距离和角度。</p>
<p>由内积引出范数和正交：定义了内积之后，我们可以构造一些数学工具方便向量空间中的度量。这里不过多介绍范数，知道范数是用来度量向量长度(大小)的即可。除了范数之外还有正交的概念。正交性在许多之后定理的证明中都有非常重要的作用，比如说需要证明一个向量是零向量，那么只要证明其和自身做内积等于零（即和自身正交）即可。正交用非常简洁的数学语言描述了 “不相干” 这种状态，是几何中垂直这个概念在更高维度上的推广。</p>
<p>接下来我们了解一下，在定义了内积的向量空间中，我们能做哪些事情。前面通过内积，我们引入了正交的概念，有了正交的概念之后，我们就可以对线性空间的一组“基”进行标准正交化了。我们希望这组“基”成为一组标准正交基，即向量之间互相正交，且向量长度为1。具体构造方法即为熟知的Gram-Schmidt正交化方法。这个正交化的过程说明了，每个有限维内积空间都有规范正交基，换句话说，Gram-Schmidt正交化过程保证了规范正交基在内积空间的存在性。</p>
<p>除了规范正交基之外，有了正交之后，还可以讨论线性空间的子空间的正交补、正交投影，向量的最佳逼近等问题。</p>
</div>
<div id="hilbert空间" class="section level2">
<h2>Hilbert空间</h2>
<p>然后在内积空间的基础上，我们可以找出它的一些具有更好性质的子空间，包括希尔伯特空间（具有完备性）。通过对内积空间做完备化处理，我们可以得到一个Hilbert空间。Hilbert空间在极限意义下具有封闭性，任意一列向量序列的极限不会跑出该空间外。</p>
</div>
<div id="再生核hilbert空间" class="section level2">
<h2>再生核Hilbert空间</h2>
<p>然后在希尔伯特空间上，我们还可以进一步定义再生核希尔伯特空间，它一类特殊的希尔伯特空间，具有许多良好的性质。</p>
<pre class="rmd"><code>这里有一点需要注意，这里向量的概念不局限于数组向量，还可以是矩阵、多项式
和函数等更抽象更广义层面上的“向量”。

我们可以看到，定义了内积之后，就会多很多数学工具，比如范数，比如内积空
间最重要的特点：正交性，当然内积空间可以继续拓展，比如加入完备性成为
Hilbert空间，这一部分将在泛函分析中讨论。</code></pre>
</div>
</div>
<div id="基本算子" class="section level1">
<h1>基本算子</h1>
<p>算子基本概念：<a href="https://zhuanlan.zhihu.com/p/148949131" class="uri">https://zhuanlan.zhihu.com/p/148949131</a></p>
<p>还有https://zhuanlan.zhihu.com/p/149167337</p>
<p>在数学中，算子一般指一个映射，它将一个空间中的元素映射成另一个空间中的元素，这两个空间可以相同，也可以不同。记<span class="math inline">\(T: W \rightarrow V\)</span>，将所有从<span class="math inline">\(W\)</span>映射到<span class="math inline">\(V\)</span>的算子记为<span class="math inline">\(\mathcal{L}(W,V)\)</span>。关于算子，数学上没有一般性的定义，但是该术语常用于定义域为一个函数空间或者其他对象（而不再是<span class="math inline">\(n\)</span>维实数空间）时。</p>
<div id="线性算子" class="section level2">
<h2>线性算子</h2>
<p>最常用的一类算子是线性算子。</p>
<p><em>定义：设<span class="math inline">\(W,V\)</span>是定义于数域<span class="math inline">\(F\)</span>上的两个向量空间，称一个映射<span class="math inline">\(A:W \rightarrow V\)</span>是线性算子，如果满足
<span class="math display">\[A(\alpha x+ \beta y)=\alpha Ax + \beta Ay\]</span>
对<span class="math inline">\(\forall ~x,y \in W,\forall \alpha,\beta \in F\)</span>成立。</em></p>
<p>在有限维向量空间的情形下（即<span class="math inline">\(W, V\)</span>都为有限维空间），线性算子可以用一个矩阵来表示。在无限维向量空间的情形下，线性算子的研究被称为泛函分析。</p>
</div>
<div id="特殊的线性算子有界算子" class="section level2">
<h2>特殊的线性算子：有界算子</h2>
<p><em>定义：假设<span class="math inline">\(U\)</span>和<span class="math inline">\(V\)</span>是定义在相同数域（比如<span class="math inline">\(R\)</span>）上的两个赋范空间，若一个从<span class="math inline">\(U\)</span>到<span class="math inline">\(V\)</span>的线性算子<span class="math inline">\(A\)</span>满足：存在一个常数<span class="math inline">\(C&gt;0\)</span>使得
<span class="math display">\[\|Ax\|_V \leq C \|x\|_U\]</span>
对<span class="math inline">\(\forall~x\in U\)</span>成立，则称线性算子<span class="math inline">\(A\)</span>是有界的。</em></p>
<p>所有的有界算子能够形成一个向量空间。在该向量空间上，我们能引入一个范数，它与<span class="math inline">\(U,V\)</span>上的范数是相容的。
<span class="math display">\[\|A\| = \inf \{C:\|Ax\|_V \leq C \|x\|_U \}.\]</span>
特别地，当<span class="math inline">\(U=V\)</span>时，可以证明：
<span class="math display">\[\|AB\|\leq \|A\|\|B\|.\]</span>
我们可以想象<span class="math inline">\(A,B\)</span>为同阶的方阵，矩阵的范数满足相容性，对应上面的式子。</p>
</div>
<div id="伴随算子" class="section level2">
<h2>伴随算子</h2>
<p>伴随算子<span class="math inline">\(A^*\)</span>在规范正交基下的矩阵是<span class="math inline">\(A\)</span>的共轭转置，其定义如下：</p>
<p><em>定义：设<span class="math inline">\(A \in \mathcal{L}(V,W),A\)</span> 的伴随是满足如下条件的算子<span class="math inline">\(A^*:W\rightarrow V:\)</span></em>对所有<span class="math inline">\(v\in V\)</span>和所有<span class="math inline">\(w\in W\)</span>均有<span class="math inline">\(\langle Av, w\rangle = \langle v, A^* w\rangle\)</span>。</p>
<pre class="rmd"><code>问题：已知算子$A$的具体形式，如何计算伴随算子的具体形式呢？</code></pre>
<p>定义完伴随后，我们可以开始正式探讨内积空间中的算子了，这一部分我们引入两个算子：自伴算子和正规算子。那么引入这两个算子是为了讨论什么问题呢？</p>
<p>当<span class="math inline">\(W=V\)</span>时，记<span class="math inline">\(\mathcal{L}(V,W)\equiv \mathcal{L}(V)\)</span>。在线性空间中对于可对角化的讨论中有这么一个结论：可对角化的充要条件是存在由特征向量所构成的一组基。而现在，在内积空间中，我们还想问：你这样的由特征向量所构成的一组基，什么时候是规范正交基。</p>
<pre class="rmd"><code>注：在矩阵分析中，也只有对称矩阵的特征向量之间是相互正交的。
对于一般方阵，特征向量的正交性不成立。</code></pre>
<p>一般的算子<span class="math inline">\(A \in \mathcal{L}(V)\)</span>不一定能够满足这一点（<span class="math inline">\(V\)</span>有一个由<span class="math inline">\(A\)</span>的特征向量构成的规范正交基），而接下来讨论的谱定理将表明，在复数域上，正规算子可以满足此要求；在实数域上，自伴算子可以满足此要求。它们就是我们所希望寻找的“好的算子”。我们可以想象：对称矩阵就可以对角化，并且它是一类特殊的算子（定义在有限维向量空间上的算子）。</p>
<pre class="rmd"><code>注：如果V是一个可数无限维的空间，那么他的一组正交基中的向量个数也是可数无穷个；
再生核希尔伯特空间就是一个可数无限维的空间，因为它的任意一个元素都可以由核的线性组合得到。</code></pre>
<p><em>定义：算子<span class="math inline">\(A \in \mathcal{L}(V)\)</span>是自伴的当且仅当<span class="math inline">\(A=A^*\)</span>。</em></p>
<p><em>定义：算子<span class="math inline">\(A \in \mathcal{L}(V)\)</span>是正规的当且仅当<span class="math inline">\(AA^*=A^*A\)</span>。</em></p>
<p>显然，自伴的条件比正规更强，自伴一定正规。从矩阵的角度讲，实数域上的自伴矩阵是对称阵，复数域上的自伴矩阵是Hermite阵；而实数域上的正规矩阵可以是对称阵、反对称征、正交阵等，但是复数域上的对称阵确不一定是正规的（思考一下反例，反例很好想）。</p>
<p>接下来看一下自伴和正规的一些特征性质。如果一个算子是正规的，则有：
1)对所有<span class="math inline">\(v\in V\)</span>均有<span class="math inline">\(\|A v\|=\|A^* v\|\)</span>；2)<span class="math inline">\(A\)</span>与<span class="math inline">\(A^*\)</span>有共轭的特征值和相同的特征向量(即<span class="math inline">\(Av=\lambda v\Rightarrow A^* v= \bar \lambda v\)</span>)；3)<span class="math inline">\(A\)</span>的不同特征值对应的特征向量是正交的。</p>
<p>我们可以从中看到正规算子所带来的一些“好的性质”： 性质1说明了<span class="math inline">\(A\)</span>和<span class="math inline">\(A^*\)</span>有相同的零空间；性质2加强了一般算子的结论，如果<span class="math inline">\(v\)</span>是<span class="math inline">\(A\)</span>相应于特征值<span class="math inline">\(\lambda\)</span>的特征向量，那么这个<span class="math inline">\(v\)</span>（而不是别的什么向量）也是<span class="math inline">\(A^*\)</span>相应于<span class="math inline">\(\bar \lambda\)</span>的特征向量；性质3说明了，在正规的条件下，不同特征值相应的特征向量不只是线性无关了，而是加强成了正交。</p>
<p>如果算子再好一点，变成自伴的，那么除了以上全部，我们还能得到：
4)算子的每个特征值都是实数；5)对所有<span class="math inline">\(v\in V\)</span>均有<span class="math inline">\(\langle Av,v\rangle =0\)</span>则<span class="math inline">\(A=0\)</span>。</p>
<p>注：性质4在实数域上自然是定义，然而在复数域上如果是自伴算子，那么仍然能够保持这个结论；在复数域上性质5自然成立，但是在实数域上，只有<span class="math inline">\(A\)</span>是自伴的才能有<span class="math inline">\(A=0\)</span>，这个性质可以理解为“0和任何向量正交”。</p>
</div>
<div id="谱定理" class="section level2">
<h2>谱定理</h2>
<p>前面说了那么多，终于讲到了这一章最核心最有趣的内容了，自伴和正规算子的引入也是为谱定理做准备。</p>
<p>谱定理是干啥的呢？在这里只需要记住一件事情，谱定理讨论的是规范正交基下的对角化。</p>
<p>对角化已经有这个结论了：<span class="math inline">\(V\)</span>上的算子关于某个基有对角矩阵当且仅当这个基是由该算子的特征向量组成的。</p>
<p>于是，前面也提到过，我们做这件事情的motivation就是，在特征基的基础上，试图找一组更好的基去刻画线性变换，即特征向量组成的规范正交基。（事实上，关于<span class="math inline">\(V\)</span>的某个规范正交基具有对角矩阵的算子已经是<span class="math inline">\(V\)</span>上最好的算子了）有了这些准备我们就可以正式来看谱定理了。</p>
<p><em>定理（复谱定理）： 设<span class="math inline">\(F=C\)</span>(复数域)且<span class="math inline">\(A \in \mathcal{L}(V)\)</span>，则以下条件等价： (a) <span class="math inline">\(A\)</span>是正规的。 (b) <span class="math inline">\(V\)</span>有一个由<span class="math inline">\(A\)</span>的特征向量构成的规范正交基。 (c) <span class="math inline">\(A\)</span>关于<span class="math inline">\(V\)</span>的某个规范正交基具有对角矩阵。</em></p>
</div>
<div id="其他算子" class="section level2">
<h2>其他算子</h2>
<p><em>定义1(迹类算子).若线性算子<span class="math inline">\(A: \mathcal{H} \rightarrow \mathcal{H}\)</span>满足
<span class="math display">\[\|A\|_1\equiv Tr(|A|)=\sum_k \langle (A^* A)^{1/2} e_k, e_k \rangle_{\mathcal{H}}&lt; \infty,\]</span>
其中<span class="math inline">\(A^*\)</span>为<span class="math inline">\(A\)</span>的伴随算子，<span class="math inline">\(|A|=\sqrt{A^*A}\)</span>，<span class="math inline">\(\{e_k\}\)</span>为<span class="math inline">\(\mathcal{H}\)</span>的一组正交基，并有
<span class="math display">\[Tr(A)=\sum_k \langle A e_k, e_k \rangle_{\mathcal{H}}\]</span>
绝对收敛且其值独立于正交基的选择，我们称<span class="math inline">\(A\)</span>为迹类算子。
</em>
当<span class="math inline">\(A\)</span>为非负自伴算子时，即使该和发散，我们仍然定义其迹为
<span class="math display">\[Tr(A)=\sum_k \langle A e_k, e_k \rangle_{\mathcal{H}}.\]</span>
于是，当<span class="math inline">\(A\)</span>为非负自伴算子时，<span class="math inline">\(A\)</span>为迹类算子的充要条件为<span class="math inline">\(Tr(A)&lt; \infty\)</span>。迹是迹类算子空间<span class="math inline">\(\mathcal{T}\)</span>上的泛函，即<span class="math inline">\(Tr: \mathcal{T} \rightarrow R\)</span>，并满足线性性质
<span class="math display">\[Tr(aA+bB)=a Tr(A) + b Tr(B),\]</span>
也就是说，迹是一个线性泛函；并且
<span class="math display">\[\langle A, B \rangle_{HS}=Tr(A^* B).\]</span></p>
<p><em>性质1. 若<span class="math inline">\(A\)</span>为有界算子，<span class="math inline">\(B\)</span>为迹类算子，则<span class="math inline">\(AB\)</span>和<span class="math inline">\(BA\)</span>也是迹类算子，且满足
<span class="math inline">\(\|AB\|_1=Tr(|AB|) \leq \|A\| \|B\|_1,\|BA\|_1=Tr(|BA|) \leq \|B\| \|A\|_1\)</span>和<span class="math inline">\(Tr(AB)=Tr(BA)\)</span>。
</em></p>
<p>若<span class="math inline">\(A\)</span>是迹类算子，则可关于<span class="math inline">\(I+A\)</span>定义Fredholm行列式，
<span class="math display">\[det(I+A)\hat= \Pi_{n\geq 1}\{1 + \lambda_n(A)\},\]</span>
其中<span class="math inline">\(\{\lambda_n(A)\}\)</span>是<span class="math inline">\(A\)</span>的谱，<span class="math inline">\(A\)</span>为迹类算子保证无限乘积为有限的且<span class="math inline">\(det(I+A)\leq e^{\|A\|_1}\)</span>，也意味着<span class="math inline">\(det(I+A)\neq 0 \Rightarrow (I+A)\)</span>是可逆的。</p>
<div id="秩1算子" class="section level3">
<h3>秩1算子</h3>
<p><em>定义2. 对任意<span class="math inline">\(f,g, h \in \mathcal{F}\)</span>，秩1算子定义为
<span class="math inline">\(f \otimes g^*(h)\hat=\langle g, h \rangle_{\mathcal{F}}f.\)</span>
</em></p>
<p>容易证明<span class="math inline">\(\|f \otimes g^* \|_{HS(\mathcal{F})}=\|f\|_\mathcal{F} \|g\|_\mathcal{F}\)</span>且<span class="math inline">\(\langle f \otimes g^* , A \rangle_{HS}=\langle A g , f \rangle_{\mathcal{F}}\)</span>，在无混淆的情形下，我们把<span class="math inline">\(HS(\mathcal{F})\)</span>简记为为<span class="math inline">\(HS\)</span>。</p>
<p><strong>证明:</strong>由<span class="math inline">\(\langle f \otimes g^* , A \rangle_{HS}= \sum_i\langle f \otimes g (e_i) , A e_i\rangle_\mathcal{F}= \sum_i \langle g, e_i\rangle_\mathcal{F} \langle f, A e_i\rangle_\mathcal{F}\)</span> <span class="math inline">\(=\sum_i \alpha_i \langle f, A e_i\rangle_\mathcal{F}= \langle f, A \sum_i \alpha_i e_i\rangle_\mathcal{F}= \langle f, A g\rangle_\mathcal{F}\)</span>，得证。 ♣</p>
</div>
</div>
</div>
</div>
				
			</article>
		</div>
	</main>
	
	



	

	</div>
	<footer class="footer">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
	<div class="footer__copyright">© 2021 Wei Liu. <a href="https://feiyoung.github.io/">HomePage </a>. <a href="https://github.com/feiyoung">Github </a></div>
</footer>
<script src="/js/menu.js"></script>
</body>
</html>