---
title: "R语言有效进行并行计算"
author: "刘伟"
date: '2021-04-15'
output: pdf_document
---

# 常用函数

```{Rmd}
single_parallel <- function(func,num_core,iterable,varlist=NULL,...){
  "
  :param func: function to be parallel computing
  :param iteralbe:a dynamic parameter(vector銆乴ist) of func.
  :param ...: all static paramters of func.
  :return list whose length is equivalent to that of iterable.
  "
  #1.load package
  library(parallel)
  #2.count the number of cores
  # cores <- detectCores(logical = FALSE)
  #3.open parallel computing nodes
  cl <- makeCluster(num_core)
  #4.pass objects for each node.
  funcname <- deparse(substitute(func))
  varlist <- c(funcname,varlist)
  clusterExport(cl, varlist = varlist, envir = environment())
  # Put the reqiured functions in GFM package into all nodes.
  clusterCall(cl, function() library(MixPPCA))
  #5.start to parallel computing
  result <- parSapply(cl=cl,X=iterable,FUN=func,...)
  #6.close parallel computing
  stopCluster(cl)
  return(result)
}

parSingle_IC <- function(K, x1, Adj_sp1, q1, cov1, ...){
  reslist <- simulDRcluster(x1,Adj_sp = Adj_sp1, q=q1, K=K, cov=cov1, ...)
  return(c(reslist$bic, reslist$aic))
}

selectClustNumber <- function(X,Adj_sp, q, K_set= 3:10, cov='heter', num_core = 1, verbose=F){
  
  if (num_core > 1) {
    if (num_core > detectCores()) {
      warning("selectClustNumber:: the number of cores you're setting is larger than detected cores!")
      num_core = detectCores()
    }
  }
  nK <- length(K_set)
  
  
  icMat <- single_parallel(parSingle_IC, num_core=num_core,
                           iterable=K_set, x1=X, Adj_sp1=Adj_sp, q1=q, cov1=cov)
  icMat <- t(icMat)
  colnames(icMat) <- c('bic', 'aic')
  return(icMat)
}
```


# 强大方便的doSNOW
doSNOW是我现在最喜欢的并行包，因为它可以显示进度条


```{Rmd}
require(doSNOW) # 加载并行包
cores <- parallel::detectCores() # 探测有多少核
cl <- makeSOCKcluster(cores) # 设定并行核
registerDoSNOW(cl) # 注册该核
mydata <- matrix(rnorm(8000*500), ncol=500) 
pb <- txtProgressBar(min=1, max=8000, style=3) # 设置并行进度条
progress <- function(n) setTxtProgressBar(pb, n) # 进度条函数
opts <- list(progress=progress) # 并性函数的参数
result <- 
  foreach(i=1:8000, .packages=NULL, .options.snow=opts, # 注意这里的.package参数非常重要
          .combine='rbind') %dopar% { # dopar%后面的内容若有需要使用到某些包的函数，这些包的名字都需要添加到.pakcage参数中
            abc <- list(tau=i^2, sl = i)
            data.frame(tau=abc$tau, sl=abc$sl) #设定该并行内容的返回值。
          }
close(pb) # 关闭进度窗
stopCluster(cl) # 关闭并行核
```

我自己定义的函数：
```{Rmd}
K_set <- 2:4
nK <- length(K_set)
pb <- txtProgressBar(min=1, max=nK, style=3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
k <- 1
res_vc <- foreach(k = 1:nK,.packages="MixPPCA" ,.options.snow=opts,
                  .combine='rbind') %dopar% {
    reslist <- simulDRcluster(X,Adj_sp = Adj_sp, q=q, K=K_set[k], cov="heter") 
  
    c(reslist$bic, reslist$aic)
}

```

为一般循环添加进度条
```{r}
testit <- function(x = sort(runif(20)), ...)
{
    pb <- txtProgressBar(...)
    for(i in c(0, x, 1)) {Sys.sleep(0.5); setTxtProgressBar(pb, i)}
    Sys.sleep(1)
    close(pb)
}
testit(style=3)
testit(runif(10), style=2)
testit(style = 4)
```