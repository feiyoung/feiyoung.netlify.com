---
title: "张量基础知识"
author: "刘伟"
date: '2020-12-24'
output: pdf_document
layout: post
---

<link href="/rmarkdown-libs/anchor-sections/anchor-sections.css" rel="stylesheet" />
<script src="/rmarkdown-libs/anchor-sections/anchor-sections.js"></script>


<p><strong>张量基础</strong></p>
<p><strong>闲居</strong></p>
<p><em>2020年12月于西财</em></p>
<div id="基础知识" class="section level1">
<h1>基础知识</h1>
<p>在介绍张量之前，我们先来了解一些基础知识，其中包括矩阵的运算和张量的运算操作。</p>
<div id="几种矩阵张量运算符号和规则" class="section level2">
<h2>几种矩阵（张量）运算符号和规则</h2>
<p>Kronecker积：设<span class="math inline">\(A \in R^{I \times J}, B \in R^{K \times L}\)</span>，表示为
<span class="math display">\[A \otimes B = (a_{ij} B) = (a_1 \otimes b_1, a_1 \otimes b_2, \cdots, a_J \otimes b_{L-1}, a_J \otimes b_L),\]</span>
其中后一个等式是从<span class="math inline">\(a_1\)</span>乘遍<span class="math inline">\(B\)</span>所有列得到，一直到<span class="math inline">\(a_J\)</span>乘遍<span class="math inline">\(B\)</span>所有列。</p>
<p>Khatri-Rao积：是“逐列配对”的Kronecker积：<span class="math inline">\(A \in R^{I \times K}, B \in R^{J \times K}\)</span>，则表示为<span class="math inline">\(A \odot B \in R^{IJ \times K}\)</span>:
<span class="math display">\[A \odot B = (a_1 \otimes b_1, a_2 \otimes b_2, \cdots, a_K \otimes b_K)\]</span></p>
<p>Hadamard乘积：指两个相同形状的矩阵的逐元乘积，表示为
<span class="math display">\[A * B = (a_{ij} b_{ij}) \in R^{I \times J}.\]</span>
张量积(Tensor product)：记为<span class="math inline">\(\bar \otimes\)</span>
设<span class="math inline">\(\mathcal{A}\in R^{I_1 \times \cdots \times I_N}, \mathcal{B}\in R^{J_1 \times \cdots \times J_M}\)</span>，则<span class="math inline">\(\mathcal{G} = \mathcal{A} \bar \otimes \mathcal{B} \in R^{I_1 \times \cdots \times I_N \times J_1 \times \cdots \times J_M}\)</span>为一个<span class="math inline">\(N+M\)</span>阶的张量，且
<span class="math display">\[g_{i_1,\cdots,i_N,j_1, \cdots,j_M}=a_{i_1,\cdots,i_N} b_{j_1, \cdots,j_M}\]</span></p>
<p>张量<span class="math inline">\(\mathcal{A}\)</span>的mode-n矩阵化，记为<span class="math inline">\(A_{(n)}\)</span>。对于三阶张量，<span class="math inline">\(A_{(1)}=( \mathcal{A}(:,:,1),\mathcal{A}(:,:,2), \cdots,\mathcal{A}(:,:,J_3))\)</span>,在计算机里面表示特别方便。</p>
<p>假设<span class="math inline">\(M\)</span>阶张量<span class="math inline">\(\mathcal{X}\in R^{I_1 \times \cdots \times I_M}\)</span>，<span class="math inline">\(Y\in R^{n \times I_j}, A \in R^{n \times I_1}, B \in R^{p \times I_2}\)</span>为矩阵。</p>
</div>
<div id="mode-j矩阵乘积" class="section level2">
<h2>Mode-j矩阵乘积</h2>
<p><span class="math display">\[\mathcal{X} \times_j Y = \mathcal{Z} \Leftrightarrow \mathcal{Z}_{(j)}=Y \mathcal{X}_{(j)}\]</span>
mode乘积的换序性质：
<span class="math display">\[\mathcal{X} \times_1 A \times_2 B = \mathcal{X}\times_2 B \times_1 A \]</span>
当<span class="math inline">\(B\)</span>的列和<span class="math inline">\(A\)</span>的行数相等时，有：
<span class="math display">\[\mathcal{X} \times_j A \times_j B = \mathcal{X}\times_j (B A) \]</span></p>
</div>
<div id="mode-j向量乘积" class="section level2">
<h2>Mode-j向量乘积</h2>
<p><span class="math inline">\(\mathcal{X} \in R^{I_1 \times \cdots \times I_N}\)</span>与向量<span class="math inline">\(v \in R^{I_n}\)</span>可以做mode-向量乘积，表示为<span class="math inline">\(\mathcal{X} \times_n v\)</span>，使得<span class="math inline">\(N\)</span>阶张量变成一个<span class="math inline">\(N-1\)</span>阶张量<span class="math inline">\(\in R^{I_1\times \cdots \times I_{n-1}~ \times ~I_{n+1} ~\times \cdots \times I_N}\)</span>，具体元素为
<span class="math display">\[(\mathcal{X} \times_n v)_{i_1, \cdots, i_{n-1},~ i_{n+1},~ \cdots, i_N}=\sum_{i_n=1}^{I_n} x_{i_1,\cdots, i_N}v_{i_n}\]</span>
它计算每个mode-n fiber与向量 <span class="math inline">\(v\)</span>的内积。
若<span class="math inline">\(m &lt;n\)</span>，我们有：
<span class="math display">\[\mathcal{X} \times_m a \times_n b=(\mathcal{X} \times_m a) \times_{n-1} b=(\mathcal{X} \times_n b) \times_{m} a\]</span></p>
</div>
<div id="krorecker乘积" class="section level2">
<h2>Krorecker乘积</h2>
<p>记<span class="math inline">\(\otimes\)</span>为Krorecker乘积，则对任意<span class="math inline">\(n \in \{1, \cdots, N\}\)</span>，有
<span class="math display">\[\mathcal{Y} = \mathcal{X} \times_1 A_1 \times_2 \cdots \times_3 A_N\Leftrightarrow \mathcal{Y}_{(n)}= A_n \mathcal{X}_{(n)} (A_N \otimes \cdots \otimes A_{n+1} \otimes A_{n-1} \otimes \cdots \otimes A_1)^T\]</span></p>
</div>
<div id="常用运算公式" class="section level2">
<h2>常用运算公式</h2>
<p>以上几种矩阵乘积运算满足一些运算性质。我认为这些性质在矢量计算中具有重要的作用，有空可以再进行研究。</p>
<p>假设<span class="math inline">\(A \in R^{I \times J}, B \in R^{K \times L}, C \in R^{J \times M}, D \in R^{L \times N}\)</span>，则
<span class="math display">\[(A \otimes B) (C \otimes D)=(AC) \otimes (BD), \]</span>
<span class="math display">\[(A \otimes B)^+= A^+ \otimes B ^+, (A \otimes B)^T= A^T \otimes B ^T,\]</span>
<span class="math display">\[A \odot B \odot C = (A \odot B) \odot C = A \odot (B \odot C)\]</span>
<span class="math display">\[(A \odot B)^T (A \odot B) = A^TA * B^TB,A \in R^{I \times J}, B \in R^{K \times J}\]</span>
<span class="math display">\[(A \odot B)^+= (A^TA * B^TB)^+ (A \odot B)^T,\]</span>
其中<span class="math inline">\(A^+\)</span>表示Moore-Penrose伪逆。</p>
<p>矩阵乘积向量化换序公式：
<span class="math display">\[vec(AXB) = (B^T \otimes A) vec (X). \tag{A1}\]</span></p>
<p>特例1：令<span class="math inline">\(B=b\)</span>为列向量，则
<span class="math display">\[AXb= (b^T \otimes A)vec(X) \tag{A3}\]</span></p>
<p>特例2：若<span class="math inline">\(X \in R^{I \times J}, b\in R^{J\times 1}\)</span>，则有
<span class="math display">\[Xb = (b^T \otimes I_I) vec(X) \in R^I, \tag{A2}\]</span>
其中<span class="math inline">\(I_I\)</span>表示<span class="math inline">\(I \times I\)</span>的单位矩阵。由<span class="math inline">\((A1)\)</span>可以直接推导出<span class="math inline">\((A2)\)</span>，因为<span class="math inline">\(Xb = I_I Xb\)</span>，列向量是一种特殊的矩阵。</p>
<p>设<span class="math inline">\(A\in R^{K\times I}, B \in R^{I \times m}, C \in R^{m \times n}\)</span>，于是基于<span class="math inline">\((A1)\)</span>，可以推导出常用的矩阵向量化边缘轮换公式：
<span class="math display">\[vec(ABC) = (I_n \otimes AB) vec(C)=(C^T B^T \otimes I_K) vec(A) \tag{A4}\]</span>
注意：第一个等式将矩阵<span class="math inline">\(C\)</span>的向量化版本轮换到最右方的边缘；第二个等式将矩阵<span class="math inline">\(A\)</span>的向量化版本轮换到最右方的边缘。在统计中这样做的好处是：如果<span class="math inline">\(A\)</span>或<span class="math inline">\(C\)</span>是我们感兴趣的参数，则<span class="math inline">\((A4)\)</span>将参数和数据分离，帮助我们推导参数的显示表达式，或者迭代的显式表达。</p>
<p><span class="math inline">\((A4)\)</span>的特例：
<span class="math display">\[vec(AB) = (I_m \otimes A) vec(B) = (B^T \otimes I_K) vec(A)  \tag{A5}\]</span>
利用(A5)，我们可以得到
<span class="math display">\[vec(ABC)= (I_n \otimes A) (C^T \otimes I_I) vec(B)  \tag{A6}\]</span>
<span class="math inline">\((A6)\)</span>告诉我们如何将夹在矩阵中间的参数轮换到边上去。</p>
<p>其他公式：1）Hardamard乘积：<span class="math inline">\(A, B \in R^{n \times m}\)</span>，
<span class="math display">\[vec(A *B) = vec(A) * vec(B)\]</span></p>
<p>2)Inner product（内积）：<span class="math inline">\(A, B \in R^{n \times m}\)</span>，
<span class="math display">\[\langle A, B\rangle = tr(A^TB)=vec(A)^T vec(B)=vec(B^T)^T vec(A)\]</span></p>
</div>
</div>
<div id="张量分解" class="section level1">
<h1>张量分解</h1>
<p>古典多元分解（也叫CP分解）是矩阵奇异值分解向张量的推广，或称为秩-<span class="math inline">\(R\)</span>分解。矩阵SVD分解的另一个推广是Tucker分解，也叫秩-<span class="math inline">\((R_1, \cdots, R_M)\)</span>分解，它计算数据张量每个模块的正交子空间。这两种分解在统计张量分析中所占的地位举足轻重。</p>
<div id="cp分解" class="section level2">
<h2>CP分解</h2>
<p><em>定义. 设数据张量空间<span class="math inline">\(F^{I_1 \times I_2 \times \cdots \times I_M} \stackrel{\sim}= F^{I_1} \otimes \cdots \otimes F^{I_M} \stackrel{\sim}= \mathcal{F}\)</span>，其中<span class="math inline">\(F\)</span>k可以为实数域<span class="math inline">\(R\)</span>，则每个<span class="math inline">\(M\)</span>阶张量<span class="math inline">\(\mathcal{A}\)</span>（在该空间<span class="math inline">\(\mathcal{F}\)</span>）都可以表示为<span class="math inline">\(R\)</span>个秩-1张量的和：
<span class="math display">\[ \mathcal{A}=\sum_{r=1}^R\lambda_r a_{1,r}\bar\otimes \cdots \bar\otimes a_{M,r}\]</span>
其中<span class="math inline">\(\lambda_r \in F, a_{m,r} \in F^{I_m}, \bar\otimes\)</span>为张量积。当上述表达式中<span class="math inline">\(R\)</span>项为最小项数时，<span class="math inline">\(R\)</span>称为张量<span class="math inline">\(\mathcal{A}\)</span>的秩，并且该分解称为秩-<span class="math inline">\(R\)</span>分解或古典多元分解；相反，当<span class="math inline">\(R\)</span>不是最小项时，称为<span class="math inline">\(R\)</span>项分解。
</em></p>
<p>显然，若<span class="math inline">\(a_{m,r} \in F^{I_m}\)</span>，张量<span class="math inline">\(a_{1,r} \bar\otimes \cdots \bar\otimes a_{M,r}\)</span>的秩为1。一般而言，计算一般<span class="math inline">\(M\)</span>阶张量的秩是一个NP-hard的问题。</p>
<p><em>定义. 对称张量：具有轮换不变性的张量称为对称张量，即
<span class="math display">\[a_{i_1,i_2,\cdots, i_M}=a_{i_{s_1}, \cdots, i_{s_M} }, \mathcal{A} =(a_{i_1,i_2,\cdots, i_M})\in F^{I^M}\]</span>
</em></p>
<pre class="rmd"><code>注：对称张量每个维度的维数都相等，比如I.</code></pre>
<p>二阶对称张量（矩阵）可以被对角化，即存在整数<span class="math inline">\(R\)</span>，非零单位向量<span class="math inline">\(v_1, \cdots, v_R \in V\)</span>和权重<span class="math inline">\(\lambda_1, \cdots, \lambda_R\)</span>使得
<span class="math display">\[\mathcal{A} = \sum_{i=1}^R \lambda_i v_i \bar\otimes v_i\]</span>
而对于一般的<span class="math inline">\(M\)</span>阶对称张量，该形式不一定存在。对于存在该形式的张量空间称为Waring空间，满足
<span class="math display">\[\mathcal{A} = \sum_{i=1}^R \lambda_i v_i^{ \otimes M},\]</span>
该分解也叫Waring分解，它是秩-<span class="math inline">\(R\)</span>分解的对称形式。在统计研究中，都是假设CP分解存在的空间，因为这个空间已经够大了，所以CP分解的存在性不必担忧。</p>
<p>与矩阵不同的是，超过二阶的张量的秩没有唯一的定义方式，比如有秩-<span class="math inline">\(R\)</span>，还有秩-<span class="math inline">\((R_1, \cdots, R_M)\)</span>，这也称为Tucker秩，该秩的定义与Tucker分解有密切的关系，而前者与秩-<span class="math inline">\(R\)</span>分解有密切关系。</p>
</div>
<div id="tucker分解" class="section level2">
<h2>Tucker分解</h2>
<p>考虑三阶张量<span class="math inline">\(\mathcal{X} \in R^{P_1 \times P_2 \times P_3}\)</span>，<span class="math inline">\(\mathcal{X}\)</span>的Tucker秩(multilinear秩)<span class="math inline">\((r_1, r_2, r_3)\)</span>定义为：
<span class="math display">\[r_1=rank_1(\mathcal{X})\equiv rank(\mathcal{X}_{(1)})=dim(span\{\mathcal{X}_{[:,i_2,i_3]}\in R^{P_1}: i_2 \leq P_2, i_3 \leq P_3\})\]</span>
为<span class="math inline">\((P_2P_3)\)</span>个<span class="math inline">\(P_1\)</span>维向量所张成的空间的维数，也是张量<span class="math inline">\(\mathcal{X}\)</span>沿着第一个方向矩阵化后的矩阵的秩；同理可得，<span class="math inline">\(r_2\)</span>为<span class="math inline">\(P_2 \times (P_1 P_3)\)</span>矩阵的秩，<span class="math inline">\(r_3\)</span>为<span class="math inline">\(P_3 \times (P_1 P_2)\)</span>矩阵的秩。</p>
<p>Tucker分解：设张量<span class="math inline">\(\mathcal{X} \in R^{P_1 \times P_2 \times P_3}\)</span>,若<span class="math inline">\(rank_j(\mathcal{X})=r_j,j \leq 3\)</span>，则存在一个Tucker分解(Tucker, 1966; De Lathamer et al., 2000)
<span class="math display">\[\mathcal{X} = \mathcal{Y} \times_1 Y_1 \times_2 Y_2 \times_3 Y_3\]</span>
其中<span class="math inline">\(\mathcal{Y} \in R^{r_1 \times r_2 \times r_3}\)</span>为核心张量(core Tensor)，<span class="math inline">\(Y_j \in R^{P_j \times r_j}\)</span>为因子矩阵。把上述分解表示为
<span class="math display">\[\mathcal{X} = [| \mathcal{Y}; Y_1,Y_2,Y_3 |]\]</span>
且<span class="math inline">\(\times_1\)</span>表示mode-1乘积：表示一个张量和一个矩阵之间的乘积。令<span class="math inline">\(Y \in R^{S \times P_j}\)</span>，则mode-j乘积为
<span class="math display">\[\mathcal{X} \times_j Y=(\sum_{k=1}^{P_j} x_{i_1, \cdots,i_k,\cdots,i_M} y_{lk}) \in R^{P_1 \times \cdots \times S \times \cdots \times P_M}\]</span>
注意到Tucker分解不是唯一的，因为<span class="math inline">\(\mathcal{X} = [| \mathcal{Y}; Y_1,Y_2,Y_3 |] = [| \mathcal{Y} \times_1 O_1 \times_2 O_2 \times_3 O_3; Y_1O_1^{-1},Y_2O_2^{-1},Y_3O_3^{-1} |]\)</span>，对于分宜非奇异矩阵<span class="math inline">\(O_j \in R^{r_j\times r_j}\)</span>。但是，Tucker分解的一种特殊情况：高阶奇异值分解(HOSVD)在一定条件下是唯一的(De Lathauner et al., 2000)。具体而言，令<span class="math inline">\(U_j\)</span>为<span class="math inline">\(\mathcal{X}_{(j)}\)</span>的前<span class="math inline">\(r_j\)</span>个左奇异矩阵(<span class="math inline">\(r_j\)</span>列)，核心张量定义为<span class="math inline">\(\mathcal{Y}=\mathcal{X} \times_1 U_1&#39; \times_2 U_2&#39; \times_3 U_3&#39;\)</span>，则<span class="math inline">\(\mathcal{Y}\)</span>有如下正交性质：对于<span class="math inline">\(1\leq j\leq 3\)</span>，有<span class="math inline">\(\mathcal{Y}_{(j)}\)</span>的行是配对正交的，并且
<span class="math display">\[\mathcal{X} = \mathcal{Y} \times_1 U_1 \times_2 U_2 \times_3 U_3\]</span>
若假设对于<span class="math inline">\(1\leq j\leq 3\)</span>，<span class="math inline">\(\mathcal{X}_{(j)}\)</span>的奇异值各不相同，且<span class="math inline">\(U_j\)</span>的每列第一个元素为正的，则HOSVD是唯一的。</p>
<pre class="rmd"><code>注：如果Y是超对角张量，则它退化为CP分解。</code></pre>
</div>
</div>
